<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DelaunayTriangulation` struct in crate `spade`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DelaunayTriangulation">

    <title>spade::DelaunayTriangulation - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>spade</a></p><script>window.sidebarCurrent = {name: 'DelaunayTriangulation', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>spade</a>::<wbr><a class='struct' href=''>DelaunayTriangulation</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-2474' class='srclink' href='../src/spade/src/delaunay.rs.html#206-213' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct DelaunayTriangulation&lt;V:&nbsp;<a class='trait' href='../spade/trait.HasPosition2D.html' title='spade::HasPosition2D'>HasPosition2D</a>,&nbsp;K&gt; <span class='where'>where V::Vector: <a class='trait' href='../spade/trait.TwoDimensional.html' title='spade::TwoDimensional'>TwoDimensional</a></span> {
    // some fields omitted
}</pre><div class='docblock'><p>A 2D Delaunay triangulation.</p>

<p>A delaunay triangulation is a special triangulation of a set of points that fulfills some
suitable properties for geometric operations like interpolation.</p>

<p>This triangulation works with <code>Vector2</code>-vectors from the <code>cgmath</code> and <code>nalgebra</code> package.
Objects that are inserted into the triangulation have to implement the <code>HasPosition2D</code> trait.</p>

<p>Implementing delaunay triangulations is all about precision: the various geometric queries
can fail if imprecise calculations are used (like native <code>f32</code> / <code>f64</code> operations), 
resulting in crashes at run time. To prevent those crashes, Spade offers a few &quot;calculation
kernels&quot; that can fit the individual needs of an application. Refer to the following table
and the documentation of each kernel for more information:</p>

<table>
<thead>
<tr>
<th></th>
<th>Vector types:</th>
<th>When to use:</th>
<th>Properties:</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>TrivialKernel</code></td>
<td>recommended: f64, i64 also supported: f32, i32</td>
<td>For i64 coordinates in the range of ± 100000. For f64 coordinates if performance is your  main concern.</td>
<td>Fastest performance. Can crash due to rounding (float types) and overflow (int types) issues.</td>
</tr>
<tr>
<td><code>FloatKernel</code></td>
<td>f64</td>
<td>Recommended for f64 coordinates.</td>
<td>Still pretty fast. Uses adaptive precise arithmetic to prevent (theoretically) all crashes.</td>
</tr>
<tr>
<td><code>AdaptiveIntKernel</code></td>
<td>i64</td>
<td>For i64 coordinates with large value range.</td>
<td>Slower than <code>FloatKernel</code>. Consider casting to floats and using those instead.</td>
</tr>
</tbody>
</table>

<h1 id='creation' class='section-header'><a href='#creation'>Creation</a></h1>
<p>A triangulation can be created with <code>&lt;kernel_name&gt;::new_triangulation()</code>, e.g.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>spade</span>::{<span class='ident'>DelaunayKernel</span>, <span class='ident'>FloatKernel</span>};
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>triangulation</span> <span class='op'>=</span> <span class='ident'>FloatKernel</span>::<span class='ident'>new_triangulation</span>();
<span class='comment'>// Once you insert the first piece of data, type inference is able to fully determine the</span>
<span class='comment'>// triangulation&#39;s type - in this case, it contains nalgebra::Vector2&lt;f64&gt;.</span>
<span class='ident'>triangulation</span>.<span class='ident'>insert</span>(<span class='ident'>nalgebra</span>::<span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>332f64</span>, <span class='number'>123f64</span>));</pre>

<p>Also, <code>Default</code> is implemented, creating a triangulation with the trivial kernel.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>nalgebra</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>spade</span>;

<span class='kw'>use</span> <span class='ident'>nalgebra</span>::{<span class='ident'>Vector2</span>};
<span class='kw'>use</span> <span class='ident'>spade</span>::{<span class='ident'>DelaunayTriangulation</span>, <span class='ident'>DelaunayTriangle</span>};

  <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>delaunay</span> <span class='op'>=</span> <span class='ident'>DelaunayTriangulation</span>::<span class='ident'>default</span>();
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>, <span class='number'>1.0</span>));
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>, <span class='op'>-</span><span class='number'>1.0</span>));
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>1.0</span>, <span class='number'>0.0</span>));
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='op'>-</span><span class='number'>1.0</span>, <span class='number'>0.0</span>));
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>, <span class='number'>0.0</span>));
  <span class='kw'>for</span> <span class='ident'>DelaunayTriangle</span>(<span class='ident'>vertices</span>) <span class='kw'>in</span> <span class='ident'>delaunay</span>.<span class='ident'>triangles</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;found triangle: {:?} -&gt; {:?} -&gt; {:?}&quot;</span>, <span class='op'>*</span><span class='ident'>vertices</span>[<span class='number'>0</span>], <span class='op'>*</span><span class='ident'>vertices</span>[<span class='number'>1</span>], <span class='op'>*</span><span class='ident'>vertices</span>[<span class='number'>2</span>]);
  }
  <span class='kw'>for</span> <span class='ident'>edge</span> <span class='kw'>in</span> <span class='ident'>delaunay</span>.<span class='ident'>edges</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;found an edge: {:?} -&gt; {:?}&quot;</span>, <span class='op'>*</span><span class='ident'>edge</span>.<span class='ident'>from_handle</span>(), <span class='op'>*</span><span class='ident'>edge</span>.<span class='ident'>to_handle</span>());
  }</pre>

<h1 id='iterating' class='section-header'><a href='#iterating'>Iterating</a></h1>
<p>A triangulation has three elements - vertices, edges and triangles - that can be iterated over.
Use <code>vertices()</code> <code>edges()</code> and <code>triangles()</code> to call appropriate, non-mutating iterators.</p>

<h1 id='mutating' class='section-header'><a href='#mutating'>Mutating</a></h1>
<p>Adding vertices is always a legal operation. Removing vertices is not possible.
Mutation of a vertex is possible with <code>lookup_mut(..)</code>.</p>

<p>While <code>VertexHandle</code>s are intended to be used for short lived 
iteration purposes, <code>FixedVertexHandle</code>s can be made persistent and have 
a <code>&#39;static</code> lifetime. A <code>VertexHandle</code> can be transformed to its fixed
variant by calling <code>VertexHandle::fix()</code>.
Use <code>handle</code> or <code>handle_mut</code> to resolve a <code>FixedVertexHandle</code>.</p>

<p>A vertex position must not be changed after the vertex has been inserted.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl&lt;V,&nbsp;K&gt; <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;K&gt; <span class='where'>where V: <a class='trait' href='../spade/trait.HasPosition2D.html' title='spade::HasPosition2D'>HasPosition2D</a>, K: <a class='trait' href='../spade/trait.DelaunayKernel.html' title='spade::DelaunayKernel'>DelaunayKernel</a>&lt;V::Vector::Scalar&gt;, V::Vector: <a class='trait' href='../spade/trait.TwoDimensional.html' title='spade::TwoDimensional'>TwoDimensional</a></span></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-2489' class='srclink' href='../src/spade/src/delaunay.rs.html#234-655' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;K&gt;</code></h4>
<div class='docblock'><p>Creates a new Delaunay triangulation.</p>

<p>Using this method directly can be a bit cumbersome due to type annotations, consider using
<code>Default::default()</code> or <code>&lt;kernel name&gt;::new_triangulation()</code> for a <code>DelaunayKernel</code> if
possible. Otherwise, you may need to specify the kernel like this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>spade</span>::{<span class='ident'>DelaunayTriangulation</span>, <span class='ident'>FloatKernel</span>};
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>triangulation</span> <span class='op'>=</span> <span class='ident'>DelaunayTriangulation</span>::<span class='op'>&lt;</span>_, <span class='ident'>FloatKernel</span><span class='op'>&gt;</span>::<span class='ident'>new</span>();
 </pre>

<p>Usually, the omitted type (the triangulation&#39;s vertex type) can be inferred after
<code>insert</code> is called.</p>
</div><h4 id='method.handle' class='method'><code>fn <a href='#method.handle' class='fnname'>handle</a>(&amp;self, handle: <a class='type' href='../spade/type.FixedVertexHandle.html' title='spade::FixedVertexHandle'>FixedVertexHandle</a>) -&gt; <a class='struct' href='../spade/struct.VertexHandle.html' title='spade::VertexHandle'>VertexHandle</a>&lt;V,&nbsp;K&gt;</code></h4>
<div class='docblock'><p>Creates a dynamic vertex handle from a fixed handle.
May panic if the handle was not obtained from this triangulation.</p>
</div><h4 id='method.handle_mut' class='method'><code>fn <a href='#method.handle_mut' class='fnname'>handle_mut</a>(&amp;mut self, handle: <a class='type' href='../spade/type.FixedVertexHandle.html' title='spade::FixedVertexHandle'>FixedVertexHandle</a>) -&gt; &amp;mut V</code></h4>
<div class='docblock'><p>Returns a mutable reference to the vertex data referenced by a
<code>FixedVertexHandle</code>. May panic if the handle was not obtained from this
triangulation.</p>
</div><h4 id='method.lookup' class='method'><code>fn <a href='#method.lookup' class='fnname'>lookup</a>(&amp;self, point: &amp;V::Vector) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../spade/struct.VertexHandle.html' title='spade::VertexHandle'>VertexHandle</a>&lt;V,&nbsp;K&gt;&gt;</code></h4>
<div class='docblock'><p>Checks if the triangulation contains an object with a given coordinate.</p>
</div><h4 id='method.lookup_mut' class='method'><code>fn <a href='#method.lookup_mut' class='fnname'>lookup_mut</a>(&amp;mut self, point: &amp;V::Vector) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;mut V&gt;</code></h4>
<div class='docblock'><p>Checks if the triangulation contains an object and returns a mutable
reference to it. Note that this will return a reference, while
<code>lookup(..)</code> returns a vertex handle.</p>
</div><h4 id='method.lookup_in_rect' class='method'><code>fn <a href='#method.lookup_in_rect' class='fnname'>lookup_in_rect</a>(&amp;self, rect: &amp;<a class='struct' href='../spade/struct.BoundingRect.html' title='spade::BoundingRect'>BoundingRect</a>&lt;V::Vector&gt;) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../spade/struct.VertexHandle.html' title='spade::VertexHandle'>VertexHandle</a>&lt;V,&nbsp;K&gt;&gt;</code></h4>
<div class='docblock'><p>Returns all vertices contained in a rectangle.</p>
</div><h4 id='method.lookup_in_circle' class='method'><code>fn <a href='#method.lookup_in_circle' class='fnname'>lookup_in_circle</a>(&amp;self, center: &amp;V::Vector, radius2: &amp;V::Vector::Scalar) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../spade/struct.VertexHandle.html' title='spade::VertexHandle'>VertexHandle</a>&lt;V,&nbsp;K&gt;&gt;</code></h4>
<div class='docblock'><p>Returns all vertices contained in a circle.</p>
</div><h4 id='method.num_vertices' class='method'><code>fn <a href='#method.num_vertices' class='fnname'>num_vertices</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of vertices in this triangulation.</p>
</div><h4 id='method.triangles' class='method'><code>fn <a href='#method.triangles' class='fnname'>triangles</a>(&amp;self) -&gt; <a class='struct' href='../spade/struct.DelaunayTriangleIterator.html' title='spade::DelaunayTriangleIterator'>DelaunayTriangleIterator</a>&lt;V,&nbsp;K&gt;</code></h4>
<div class='docblock'><p>Returns an iterator over all triangles.</p>
</div><h4 id='method.edges' class='method'><code>fn <a href='#method.edges' class='fnname'>edges</a>(&amp;self) -&gt; <a class='struct' href='../spade/struct.AllEdgesIterator.html' title='spade::AllEdgesIterator'>AllEdgesIterator</a>&lt;V,&nbsp;K&gt;</code></h4>
<div class='docblock'><p>Returns an iterator over all edges.</p>
</div><h4 id='method.vertices' class='method'><code>fn <a href='#method.vertices' class='fnname'>vertices</a>(&amp;self) -&gt; <a class='struct' href='../spade/struct.AllVerticesIterator.html' title='spade::AllVerticesIterator'>AllVerticesIterator</a>&lt;V,&nbsp;K&gt;</code></h4>
<div class='docblock'><p>Returns an iterator over all vertices.</p>
</div><h4 id='method.get_position_in_triangulation' class='method'><code>fn <a href='#method.get_position_in_triangulation' class='fnname'>get_position_in_triangulation</a>(&amp;self, point: &amp;V::Vector) -&gt; <a class='enum' href='../spade/enum.PositionInTriangulation.html' title='spade::PositionInTriangulation'>PositionInTriangulation</a>&lt;<a class='struct' href='../spade/struct.VertexHandle.html' title='spade::VertexHandle'>VertexHandle</a>&lt;V,&nbsp;K&gt;&gt;</code></h4>
<div class='docblock'><p>Returns information about the location of a point in a triangulation.</p>
</div><h4 id='method.insert' class='method'><code>fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, t: V) -&gt; <a class='type' href='../spade/type.FixedVertexHandle.html' title='spade::FixedVertexHandle'>FixedVertexHandle</a></code></h4>
<div class='docblock'><p>Inserts a new vertex into the triangulation
This operations runs in O(log n) on average, n denotes the number of vertices contained
in the triangulation. If the point has already been contained in the
triangulation, the old vertex is overwritten.</p>

<p>Returns a handle to the new vertex. Use this handle with
<code>DelaunayTriangulation::handle(..)</code> to refer to the vertex.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;V,&nbsp;K&gt; <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;K&gt; <span class='where'>where V: <a class='trait' href='../spade/trait.HasPosition2D.html' title='spade::HasPosition2D'>HasPosition2D</a>, V::Vector::Scalar: <a class='trait' href='../spade/trait.SpadeFloat.html' title='spade::SpadeFloat'>SpadeFloat</a>, K: <a class='trait' href='../spade/trait.DelaunayKernel.html' title='spade::DelaunayKernel'>DelaunayKernel</a>&lt;V::Vector::Scalar&gt;, V::Vector: <a class='trait' href='../spade/trait.TwoDimensional.html' title='spade::TwoDimensional'>TwoDimensional</a></span></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-2672' class='srclink' href='../src/spade/src/delaunay.rs.html#657-1089' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.nn_interpolation' class='method'><code>fn <a href='#method.nn_interpolation' class='fnname'>nn_interpolation</a>&lt;R,&nbsp;F:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; R&gt;(&amp;self, point: &amp;V::Vector, f: F) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;R&gt; <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Mul.html' title='core::ops::Mul'>Mul</a>&lt;V::Vector::Scalar,&nbsp;Output=R&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Add.html' title='core::ops::Add'>Add</a>&lt;Output=R&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Sub.html' title='core::ops::Sub'>Sub</a>&lt;R&gt;</span></code></h4>
<div class='docblock'><p>Performs a natural neighbor interpolation for a given position.</p>

<p>Returns <code>None</code> if the triangulation has no triangles yet.
Points outside of the convex hull will be interpolated as well.
This operation runs in O(log n) for n inserted vertices.</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1>
<pre class='rust rust-example-rendered'>


<span class='kw'>struct</span> <span class='ident'>PointWithHeight</span> {
  <span class='ident'>point</span>: <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>,
  <span class='ident'>height</span>: <span class='ident'>f32</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasPosition</span> <span class='kw'>for</span> <span class='ident'>PointWithHeight</span> {
  <span class='kw'>type</span> <span class='ident'>Vector</span> <span class='op'>=</span> <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>position</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span> {
      <span class='self'>self</span>.<span class='ident'>point</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>delaunay</span> <span class='op'>=</span> <span class='ident'>DelaunayTriangulation</span>::<span class='ident'>default</span>();
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>PointWithHeight</span> { <span class='ident'>point</span>: <span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>, <span class='number'>0.0</span>), <span class='ident'>height</span>: <span class='number'>5.</span> });
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>PointWithHeight</span> { <span class='ident'>point</span>: <span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>1.0</span>, <span class='number'>0.0</span>), <span class='ident'>height</span>: <span class='number'>0.</span> });
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>PointWithHeight</span> { <span class='ident'>point</span>: <span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>, <span class='number'>1.0</span>), <span class='ident'>height</span>: <span class='number'>0.</span> });
  <span class='kw'>let</span> <span class='ident'>lookup</span> <span class='op'>=</span> <span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.2</span>, <span class='number'>0.2</span>);
  <span class='comment'>// Interpolate the points height</span>
  <span class='kw'>let</span> <span class='ident'>interpolated</span> <span class='op'>=</span> <span class='ident'>delaunay</span>.<span class='ident'>nn_interpolation</span>(<span class='kw-2'>&amp;</span><span class='ident'>lookup</span>, <span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> <span class='ident'>p</span>.<span class='ident'>height</span>).<span class='ident'>unwrap</span>();
  <span class='comment'>// and insert it afterwards.</span>
  <span class='ident'>delaunay</span>.<span class='ident'>insert</span>(<span class='ident'>PointWithHeight</span> { <span class='ident'>point</span>: <span class='ident'>lookup</span>, <span class='ident'>height</span>: <span class='ident'>interpolated</span> });
  <span class='comment'>// Data points themselves will always yield their own height</span>
  <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>delaunay</span>.<span class='ident'>nn_interpolation</span>(<span class='kw-2'>&amp;</span><span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.0</span>, <span class='number'>0.0</span>), <span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> <span class='ident'>p</span>.<span class='ident'>height</span>),
             <span class='prelude-val'>Some</span>(<span class='number'>5.0</span>));
}</pre>
</div><h4 id='method.estimate_normals' class='method'><code>fn <a href='#method.estimate_normals' class='fnname'>estimate_normals</a>&lt;F,&nbsp;G,&nbsp;RV&gt;(&amp;mut self, f: &amp;F, g: G) <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; V::Vector::Scalar, G: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;mut V, RV), RV: <a class='trait' href='../spade/trait.ThreeDimensional.html' title='spade::ThreeDimensional'>ThreeDimensional</a>&lt;Scalar=V::Vector::Scalar&gt;</span></code></h4>
<div class='docblock'><p>Estimates a normal for each vertex in the triangulation.</p>

<p><code>f</code> must yield a &quot;height&quot; value for each vertex,
<code>g</code> is a callback function that can be used to store the calculated normals.</p>

<pre class='rust rust-example-rendered'>
 

<span class='kw'>struct</span> <span class='ident'>PointWithHeight</span> {
  <span class='ident'>point</span>: <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>,
  <span class='ident'>normal</span>: <span class='ident'>Vector3</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>,
  <span class='ident'>height</span>: <span class='ident'>f32</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasPosition</span> <span class='kw'>for</span> <span class='ident'>PointWithHeight</span> {
  <span class='kw'>type</span> <span class='ident'>Vector</span> <span class='op'>=</span> <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>position</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span> {
      <span class='self'>self</span>.<span class='ident'>point</span>
    }
}
<span class='kw'>impl</span> <span class='ident'>PointWithHeight</span> {
  <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>point</span>: <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>, <span class='ident'>height</span>: <span class='ident'>f32</span>) <span class='op'>-&gt;</span> <span class='ident'>PointWithHeight</span> {
    <span class='ident'>PointWithHeight</span> { <span class='ident'>point</span>: <span class='ident'>point</span>, <span class='ident'>height</span>: <span class='ident'>height</span>, <span class='ident'>normal</span>: <span class='ident'>Vector3</span>::<span class='ident'>new</span>(<span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>) }
  }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>delaunay</span> <span class='op'>=</span> <span class='ident'>DelaunayTriangulation</span>::<span class='ident'>default</span>();
  <span class='comment'>// Insert some points here... (skipped)</span>
  <span class='comment'>// Then, estimate all normals at once:</span>
  <span class='ident'>delaunay</span>.<span class='ident'>estimate_normals</span>(<span class='kw-2'>&amp;</span>(<span class='op'>|</span><span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='ident'>PointWithHeight</span><span class='op'>|</span> <span class='ident'>v</span>.<span class='ident'>height</span>), <span class='kw-2'>&amp;</span>(<span class='op'>|</span><span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>PointWithHeight</span>, <span class='ident'>n</span><span class='op'>|</span> <span class='ident'>v</span>.<span class='ident'>normal</span> <span class='op'>=</span> <span class='ident'>n</span>));
   
  <span class='comment'>// And print them</span>
  <span class='kw'>for</span> <span class='ident'>vertex</span> <span class='kw'>in</span> <span class='ident'>delaunay</span>.<span class='ident'>vertices</span>() {
     <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;vertex: {:?}, normal: {:?}&quot;</span>, <span class='ident'>vertex</span>.<span class='ident'>position</span>(), <span class='ident'>vertex</span>.<span class='ident'>normal</span>);
  }
}</pre>
</div><h4 id='method.estimate_normal' class='method'><code>fn <a href='#method.estimate_normal' class='fnname'>estimate_normal</a>&lt;F,&nbsp;RV&gt;(&amp;self, v: <a class='type' href='../spade/type.FixedVertexHandle.html' title='spade::FixedVertexHandle'>FixedVertexHandle</a>, f: &amp;F) -&gt; RV <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; V::Vector::Scalar, RV: <a class='trait' href='../spade/trait.ThreeDimensional.html' title='spade::ThreeDimensional'>ThreeDimensional</a>&lt;Scalar=V::Vector::Scalar&gt;</span></code></h4>
<div class='docblock'><p>Estimates a normal value for a given vertex.</p>

<p>This assumes that the triangulation models some kind of height field, given by the
function <code>f</code>.
The normal is the weighted and normalized average of the normals of all triangles
adjacent to the given vertex.</p>
</div><h4 id='method.estimate_gradients' class='method'><code>fn <a href='#method.estimate_gradients' class='fnname'>estimate_gradients</a>&lt;F,&nbsp;G&gt;(&amp;mut self, f: &amp;F, g: &amp;G) <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; V::Vector::Scalar, G: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;mut V, V::Vector)</span></code></h4>
<div class='docblock'><p>Estimates gradients for all vertices in this triangulation.</p>

<p><code>f</code> yields the value for which a gradient should be calculated,
<code>g</code> can be used to store the gradient. See <code>estimate_normals</code> for a similar example.</p>

<p>Internally, the normal for each vertex is calculated first. Then, an appropriate
gradient is calculated.</p>
</div><h4 id='method.estimate_gradient' class='method'><code>fn <a href='#method.estimate_gradient' class='fnname'>estimate_gradient</a>&lt;F,&nbsp;G&gt;(&amp;self, v: <a class='type' href='../spade/type.FixedVertexHandle.html' title='spade::FixedVertexHandle'>FixedVertexHandle</a>, f: &amp;F) -&gt; V::Vector <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; V::Vector::Scalar</span></code></h4>
<div class='docblock'><p>Estimates and returns the gradient for a single vertex in this triangulation.</p>
</div><h4 id='method.nn_interpolation_c1_sibson' class='method'><code>fn <a href='#method.nn_interpolation_c1_sibson' class='fnname'>nn_interpolation_c1_sibson</a>&lt;F:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; V::Vector::Scalar,&nbsp;G:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(&amp;V) -&gt; V::Vector&gt;(&amp;self, point: &amp;V::Vector, f: F, g: G) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;V::Vector::Scalar&gt;</code></h4>
<div class='docblock'><p>Interpolates a data point on this triangulation according to Sibson&#39;s c1 interpolant.</p>

<p>The interpolation given by <code>nn_interpolation</code> is not differentiable at the triangulation&#39;s
data points. Sibson introduced another interpolation scheme that takes the gradient of each
data point into account and offers an interpolation that is differentiable (c1) at the data
points.
The interpolation needs to know the gradients of the points natural neighbors, though.
Spade can estimate them automatically, see <code>estimate_gradient</code> and <code>estimate_gradients</code>.
The value that should be interpolated is given by <code>f</code>, the gradient of a vertex must
be given by <code>g</code>.</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1>
<pre class='rust rust-example-rendered'>
 
<span class='kw'>struct</span> <span class='ident'>PointWithHeight</span> {
  <span class='ident'>point</span>: <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>,
  <span class='ident'>gradient</span>: <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>,
  <span class='ident'>height</span>: <span class='ident'>f32</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasPosition</span> <span class='kw'>for</span> <span class='ident'>PointWithHeight</span> {
  <span class='kw'>type</span> <span class='ident'>Vector</span> <span class='op'>=</span> <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>position</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span> {
      <span class='self'>self</span>.<span class='ident'>point</span>
    }
}

<span class='kw'>impl</span> <span class='ident'>PointWithHeight</span> {
  <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>point</span>: <span class='ident'>Vector2</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>, <span class='ident'>height</span>: <span class='ident'>f32</span>) <span class='op'>-&gt;</span> <span class='ident'>PointWithHeight</span> {
    <span class='comment'>// Initialize the gradient to any value since it will be overwritten</span>
    <span class='ident'>PointWithHeight</span> { <span class='ident'>point</span>: <span class='ident'>point</span>, <span class='ident'>height</span>: <span class='ident'>height</span>, <span class='ident'>gradient</span>: <span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.</span>, <span class='number'>0.</span>) }
  }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>delaunay</span> <span class='op'>=</span> <span class='ident'>DelaunayTriangulation</span>::<span class='ident'>default</span>();
  <span class='comment'>// Insert some points here...</span>
  <span class='comment'>// Estimate all gradients and store them:</span>
  <span class='ident'>delaunay</span>.<span class='ident'>estimate_gradients</span>(<span class='kw-2'>&amp;</span>(<span class='op'>|</span><span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='ident'>PointWithHeight</span><span class='op'>|</span> <span class='ident'>v</span>.<span class='ident'>height</span>),
                              <span class='kw-2'>&amp;</span>(<span class='op'>|</span><span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>PointWithHeight</span>, <span class='ident'>g</span><span class='op'>|</span> <span class='ident'>v</span>.<span class='ident'>gradient</span> <span class='op'>=</span> <span class='ident'>g</span>));
   
  <span class='comment'>// Now we can use the gradients for interpolation:</span>
 <span class='kw'>let</span> <span class='ident'>interpolated</span> <span class='op'>=</span> <span class='ident'>delaunay</span>.<span class='ident'>nn_interpolation_c1_sibson</span>(
     <span class='kw-2'>&amp;</span><span class='ident'>Vector2</span>::<span class='ident'>new</span>(<span class='number'>0.5</span>, <span class='number'>0.2</span>), <span class='op'>|</span><span class='ident'>v</span><span class='op'>|</span> <span class='ident'>v</span>.<span class='ident'>height</span>, <span class='op'>|</span><span class='ident'>v</span><span class='op'>|</span> <span class='ident'>v</span>.<span class='ident'>gradient</span>);
 <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;interpolated: {}&quot;</span>, <span class='ident'>interpolated</span>.<span class='ident'>unwrap</span>());
}</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl&lt;V:&nbsp;<a class='trait' href='../spade/trait.HasPosition2D.html' title='spade::HasPosition2D'>HasPosition2D</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>,&nbsp;K&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;K&gt; <span class='where'>where V::Vector: <a class='trait' href='../spade/trait.TwoDimensional.html' title='spade::TwoDimensional'>TwoDimensional</a></span></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-2481' class='srclink' href='../src/spade/src/delaunay.rs.html#215-224' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;K&gt;</code></h4>
<div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;V&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html' title='core::default::Default'>Default</a> for <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;<a class='struct' href='../spade/struct.TrivialKernel.html' title='spade::TrivialKernel'>TrivialKernel</a>&gt; <span class='where'>where V: <a class='trait' href='../spade/trait.HasPosition2D.html' title='spade::HasPosition2D'>HasPosition2D</a>, V::Vector: <a class='trait' href='../spade/trait.TwoDimensional.html' title='spade::TwoDimensional'>TwoDimensional</a></span></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-2486' class='srclink' href='../src/spade/src/delaunay.rs.html#226-232' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.default' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../spade/struct.DelaunayTriangulation.html' title='spade::DelaunayTriangulation'>DelaunayTriangulation</a>&lt;V,&nbsp;<a class='struct' href='../spade/struct.TrivialKernel.html' title='spade::TrivialKernel'>TrivialKernel</a>&gt;</code></h4>
<div class='docblock'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "spade";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>